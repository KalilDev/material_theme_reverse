<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>

    const data = {};

    const getIndex = (r, g, b) => (r << 10) + (r << 6) + r + (g << 5) + g + b;
    const intFromRgb = rgb => (-16777216 | (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255) >>> 0
    const linearized = rgb => .04045 >= rgb ? rgb / 12.92 : Math.pow((rgb + .055) / 1.055, 2.4)
    const delinearized = rgb => .0031308 >= rgb ? 12.92 * rgb : 1.055 * Math.pow(rgb, 1 / 2.4) - .055;
    const WHITE_POINT_D65 = [95.047, 100, 108.883]
    const hexFromInt = argb => {
        const g = (argb & 65280) >> 8
        const b = argb & 255
        const outParts = [((argb & 16711680) >> 16).toString(16), g.toString(16), b.toString(16)];

        for (const [chunk1, chunk2] of outParts.entries()) {
            const i = chunk1
            const part = chunk2;
            
            1 === part.length && (outParts[i] = "0" + part)
        }
        return "#" + outParts.join("")
    }


    window.addEventListener('click', function () {
        const url = "https://images.unsplash.com/photo-1493612276216-ee3925520721?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=764&q=80";
        seedFromImage(url)
            .then((color) => {
                document.bgColor = color;
                console.log("The seed color of " + url + " is " + color)
            })
    });


    const labFromInt = argb => {
        const e = 216 / 24389
        const kappa = 24389 / 27
        const redL = 100 * linearized(((argb & 16711680) >> 16) / 255)
        const greenL = 100 * linearized(((argb & 65280) >> 8) / 255)
        const blueL = 100 * linearized((argb & 255) / 255)
        const yNormalized = (.2126 * redL + .7152 * greenL + .0722 * blueL) / WHITE_POINT_D65[1];
        
        const fy = yNormalized > e ? Math.pow(yNormalized, 1 / 3) : (kappa * yNormalized + 16) / 116;
        const xNormalized = (.41233895 * redL + .35762064 * greenL + .18051042 * blueL) / WHITE_POINT_D65[0]
        const zNormalized = (.01932141 * redL + .11916382 * greenL + .95034478 * blueL) / WHITE_POINT_D65[2];
        return [116 * fy - 16, 500 * ((xNormalized > e ? Math.pow(xNormalized, 1 / 3) : (kappa * xNormalized + 16) / 116) - fy), 200 * (fy - (zNormalized > e ? Math.pow(zNormalized, 1 / 3) : (kappa * zNormalized + 16) / 116))]
    }


    const QuantizerWu = class {
        constructor() {
            this.weights = [];
            this.momentsR = [];
            this.momentsG = [];
            this.momentsB = [];
            this.moments = [];
            this.cubes = []
        }
        volume(cube, moment) {
            return moment[getIndex(cube.r1, cube.g1, cube.b1)] - moment[getIndex(cube.r1, cube.g1, cube.b0)] - moment[getIndex(cube.r1, cube.g0, cube.b1)] + moment[getIndex(cube.r1, cube.g0, cube.b0)] - moment[getIndex(cube.r0, cube.g1, cube.b1)] + moment[getIndex(cube.r0, cube.g1, cube.b0)] + moment[getIndex(cube.r0, cube.g0, cube.b1)] - moment[getIndex(cube.r0, cube.g0, cube.b0)]
        }
        bottom(cube, direction, moment) {
            switch (direction) {
                case "red":
                    return -moment[getIndex(cube.r0, cube.g1, cube.b1)] + moment[getIndex(cube.r0, cube.g1, cube.b0)] + moment[getIndex(cube.r0, cube.g0, cube.b1)] - moment[getIndex(cube.r0, cube.g0, cube.b0)];
                case "green":
                    return -moment[getIndex(cube.r1, cube.g0, cube.b1)] + moment[getIndex(cube.r1, cube.g0, cube.b0)] + moment[getIndex(cube.r0, cube.g0, cube.b1)] - moment[getIndex(cube.r0, cube.g0, cube.b0)];
                case "blue":
                    return -moment[getIndex(cube.r1, cube.g1, cube.b0)] + moment[getIndex(cube.r1, cube.g0, cube.b0)] + moment[getIndex(cube.r0, cube.g1, cube.b0)] - moment[getIndex(cube.r0, cube.g0, cube.b0)];
                default:
                    throw Error("unexpected direction $direction");
            }
        }
        top(cube, direction, position, moment) {
            switch (direction) {
                case "red":
                    return moment[getIndex(position, cube.g1, cube.b1)] - moment[getIndex(position, cube.g1, cube.b0)] - moment[getIndex(position, cube.g0, cube.b1)] + moment[getIndex(position, cube.g0, cube.b0)];
                case "green":
                    return moment[getIndex(cube.r1, position, cube.b1)] - moment[getIndex(cube.r1, position, cube.b0)] - moment[getIndex(cube.r0, position, cube.b1)] + moment[getIndex(cube.r0, position, cube.b0)];
                case "blue":
                    return moment[getIndex(cube.r1, cube.g1, position)] - moment[getIndex(cube.r1, cube.g0, position)] - moment[getIndex(cube.r0, cube.g1, position)] + moment[getIndex(cube.r0, cube.g0, position)];
                default:
                    throw Error("unexpected direction $direction");
            }
        }
    }



    const libmonetfromIntInViewingConditions = function (argb) {
        const redL = 100 * linearized(((argb & 16711680) >> 16) / 255)
        const greenL = 100 * linearized(((argb & 65280) >> 8) / 255)
        const blueL = 100 * linearized((argb & 255) / 255)
        const x = .41233895 * redL + .35762064 * greenL + .18051042 * blueL
        const y = .2126 * redL + .7152 * greenL + .0722 * blueL
        const z = .01932141 * redL + .11916382 * greenL + .95034478 * blueL
        const rD = ViewingConditionsDEFAULT.rgbD[0] * (.401288 * x + .650173 * y - .051461 * z)
        const gD = ViewingConditionsDEFAULT.rgbD[1] * (-.250268 * x + 1.204414 * y + .045854 * z)
        const bD = ViewingConditionsDEFAULT.rgbD[2] * (-.002079 * x + .048952 * y + .953127 * z)
        const rAF = Math.pow(ViewingConditionsDEFAULT.fl * Math.abs(rD) / 100, .42)
        const gAF = Math.pow(ViewingConditionsDEFAULT.fl * Math.abs(gD) / 100, .42)
        const bAF = Math.pow(ViewingConditionsDEFAULT.fl * Math.abs(bD) / 100, .42)
        const rA = 400 * math_utils_signum(rD) * rAF / (rAF + 27.13)
        const gA = 400 * math_utils_signum(gD) * gAF / (gAF + 27.13)
        const bA = 400 * math_utils_signum(bD) * bAF / (bAF + 27.13)
        const a = (11 * rA + -12 * gA + bA) / 11
        const b = (rA + gA - 2 * bA) / 9
        const atanDegrees = 180 * Math.atan2(b, a) / Math.PI
        const hue = 0 > atanDegrees ? atanDegrees + 360 : 360 <= atanDegrees ? atanDegrees - 360 : atanDegrees
        const hueRadians = hue * Math.PI / 180
        const j = 100 * Math.pow((40 * rA + 20 * gA + bA) / 20 * ViewingConditionsDEFAULT.nbb / ViewingConditionsDEFAULT.aw, ViewingConditionsDEFAULT.c * ViewingConditionsDEFAULT.z)
        const alpha = Math.pow(5E4 / 13 * .25 * (Math.cos((20.14 > hue ? hue + 360 : hue) * Math.PI / 180 + 2) + 3.8)
                * ViewingConditionsDEFAULT.nc * ViewingConditionsDEFAULT.ncb * Math.sqrt(a * a + b * b) / ((20 * rA + 20 * gA + 21 * bA) / 20 + .305), .9) * Math.pow(1.64 - Math.pow(.29, ViewingConditionsDEFAULT.n), .73)
        const c = alpha * Math.sqrt(j / 100)
        const mstar = 1 / .0228 * Math.log(1 + .0228 * c * ViewingConditionsDEFAULT.fLRoot);
        
        return new libMonetCam16Class(
            hue,
            c,
            j,
            4 / ViewingConditionsDEFAULT.c * Math.sqrt(j / 100) * (ViewingConditionsDEFAULT.aw + 4) * ViewingConditionsDEFAULT.fLRoot,
            50 * Math.sqrt(alpha * ViewingConditionsDEFAULT.c / (ViewingConditionsDEFAULT.aw + 4)),
            (1 + 100 * .007) * j / (1 + .007 * j),
            mstar * Math.cos(hueRadians),
            mstar * Math.sin(hueRadians),
        )
    }

    const ViewingConditionsClass = class {
        constructor(n, aw, nbb, ncb, c, nc, rgbD, fl, fLRoot, z) {
            this.n = n;
            this.aw = aw;
            this.nbb = nbb;
            this.ncb = ncb;
            this.c = c;
            this.nc = nc;
            this.rgbD = rgbD;
            this.fl = fl;
            this.fLRoot = fLRoot;
            this.z = z
        }
    }

    var ViewingConditionsDEFAULT = function (whitePoint = WHITE_POINT_D65, adaptingLuminance = 200 / Math.PI * 100 * Math.pow(66 / 116, 3) / 100, backgroundLstar = 50, surround = 2, discountingIlluminant = !1) {
        const rW = .401288 * whitePoint[0] + .650173 * whitePoint[1] + -.051461 * whitePoint[2]
        const gW = -.250268 * whitePoint[0] + 1.204414 * whitePoint[1] + .045854 * whitePoint[2]
        const bW = -.002079 * whitePoint[0] + .048952 * whitePoint[1] + .953127 * whitePoint[2]
        const f = .8 + surround / 10;

        if (.9 <= f) {
            const amount = 10 * (f - .9);
            var temp = .59 * (1 - amount) + .69 * amount
        } else {
            const amountTemp = 10 * (f - .8);
            temp = .525 * (1 - amountTemp) + .59 * amountTemp
        }

        let d = discountingIlluminant ? 1 : f * (1 - 1 / 3.6 * Math.exp((-adaptingLuminance - 42) / 92));
        
        d = 1 < d ? 1 : 0 > d ? 0 : d;

        const rgbD = [100 / rW * d + 1 - d, 100 / gW * d + 1 - d, 100 / bW * d + 1 - d]
        const k = 1 / (5 * adaptingLuminance + 1)
        const k4 = k * k * k * k
        const k4F = 1 - k4
        const fl = k4 * adaptingLuminance + .1 * k4F * k4F * Math.cbrt(5 * adaptingLuminance)
        const n = (8 < backgroundLstar ? 100 * Math.pow((backgroundLstar + 16) / 116, 3) : backgroundLstar / (24389 / 27) * 100) / whitePoint[1]
        const nbb = .725 / Math.pow(n, .2)
        const rgbAFactors = [Math.pow(fl * rgbD[0] * rW / 100, .42), Math.pow(fl * rgbD[1] * gW / 100, .42), Math.pow(fl * rgbD[2] * bW / 100, .42)]
        const rgbA = [400 * rgbAFactors[0] / (rgbAFactors[0] + 27.13), 400 * rgbAFactors[1] / (rgbAFactors[1] + 27.13), 400 * rgbAFactors[2] / (rgbAFactors[2] + 27.13)];
        return new ViewingConditionsClass(n, (2 * rgbA[0] + rgbA[1] + .05 * rgbA[2]) * nbb, nbb, nbb, temp, f, rgbD, fl, Math.pow(fl, .25), 1.48 + Math.sqrt(n))
    }();

    const image_utils_decodeToImageData = async (bytes) => {
        const url = URL.createObjectURL(new Blob([bytes], {
            type: "image/png"
        }));

        const image = await new Promise((resolve, reject) => {
            const img = new Image;
            img.onload = () => {
                resolve(img)
            };
            img.onerror = () => {
                reject()
            };
            img.src = url
        })
        const ctx = document.createElement("canvas").getContext("2d");
        ctx.canvas.width = 112;
        ctx.canvas.height = 112;
        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, ctx.canvas.width, ctx.canvas.height);
        return ctx.getImageData(0, 0, image.width, image.height)
    }

    async function bufferToPixels(buffer) {
        const imageBytes = new Uint8Array(buffer)
        const imageData = await image_utils_decodeToImageData(imageBytes)
        const pixels = [];
        for (let i = 0; i < imageData.data.length; i += 4)
            255 > imageData.data[i + 3] || pixels.push(intFromRgb([imageData.data[i], imageData.data[i + 1], imageData.data[i + 2]]));
        return pixels
    }

    function math_utils_clamp(max, input) {
        return Math.min(Math.max(input, 0), max)
    }

    const intFromXyzComponents = (x, y, z) => {
        x /= 100;
        y /= 100;
        z /= 100;
        return intFromRgb(
            [
                Math.round(math_utils_clamp(255, 255 * delinearized(3.2406 * x + -1.5372 * y + -.4986 * z))), 
                Math.round(math_utils_clamp(255, 255 * delinearized(-.9689 * x + 1.8758 * y + .0415 * z))), 
                Math.round(math_utils_clamp(255, 255 * delinearized(.0557 * x + -.204 * y + 1.057 * z)))
            ]
        )
    }

    const lstarFromInt = argb => {
        let y = 21.26 * linearized(((argb & 16711680) >> 16) / 255) + 71.52 * linearized(((argb & 65280) >> 8) / 255) + 7.22 * linearized((argb & 255) / 255);
        y /= 100;
        return y <= 216 / 24389 ? 24389 / 27 * y : 116 * Math.pow(y, 1 / 3) - 16
    }

    var LabPointProvider = class {
        toInt(point) {
            var l = point[0];
            const e = 216 / 24389
            const kappa = 24389 / 27
            const fy = (l + 16) / 116
            const fx = point[1] / 500 + fy
            const fz = fy - point[2] / 200
            const fx3 = fx * fx * fx
            const fz3 = fz * fz * fz;
            
            const xyz = [
                (fx3 > e ? fx3 : (116 * fx - 16) / kappa) * WHITE_POINT_D65[0], 
                (8 < l ? fy * fy * fy : l / kappa) * WHITE_POINT_D65[1], 
                (fz3 > e ? fz3 : (116 * fz - 16) / kappa) * WHITE_POINT_D65[2]
            ];
            return intFromXyzComponents(xyz[0], xyz[1], xyz[2])
        }
        distance(from, to) {
            const dL = from[0] - to[0]
            const dA = from[1] - to[1]
            const dB = from[2] - to[2];
            return dL * dL + dA * dA + dB * dB
        }
    }

    function math_utils_signum(input) {
        return 0 > input ? -1 : 0 === input ? 0 : 1
    }

    var libMonetCam16Class = class {
        constructor(hue, chroma, j, q, s, jstar, astar, bstar) {
            this.hue = hue;
            this.chroma = chroma;
            this.j = j;
            this.q = q;
            this.s = s;
            this.jstar = jstar;
            this.astar = astar;
            this.bstar = bstar
        }
        distance(other) {
            const dJ = this.jstar - other.jstar
            const dA = this.astar - other.astar
            const dB = this.bstar - other.bstar;
            return 1.41 * Math.pow(Math.sqrt(dJ * dJ + dA * dA + dB * dB), .63)
        }
    }


    class quantizer_wsmeans_DistanceAndIndex {
        constructor() {
            this.index = this.distance = -1
        }
    }

    var createBoxes = function (self) {
        self.cubes = Array.from({ length: 256 }).fill(0).map(() => new quantizer_wu_Box);
        
        const volumeVariance = Array.from({  length: 256 }).fill(0);

        self.cubes[0].r0 = 0;
        self.cubes[0].g0 = 0;
        self.cubes[0].b0 = 0;
        self.cubes[0].r1 = 32;
        self.cubes[0].g1 = 32;
        self.cubes[0].b1 = 32;
        
        let generatedColorCount = 256
        let next = 0;
        
        for (let i = 1; 256 > i; i++) {
            cut(self, self.cubes[next], self.cubes[i])
                     ? (volumeVariance[next] = 1 < self.cubes[next].vol 
                     ? variance(self, self.cubes[next]) : 0, volumeVariance[i] = 1 < self.cubes[i].vol 
                     ? variance(self, self.cubes[i]) : 0) : (volumeVariance[next] = 0, i--);
            next = 0;
            let temp = volumeVariance[0];
            for (let j = 1; j <= i; j++)
                volumeVariance[j] > temp && (temp = volumeVariance[j], next = j);
            if (0 >= temp) {
                generatedColorCount = i + 1;
                break
            }
        }
        return new quantizer_wu_CreateBoxesResult(generatedColorCount)
    }

    async function seedFromImage(image) {
        const imageBuffer = "string" === typeof image ? await (await fetch(image)).arrayBuffer() : image;
        var pixels = await bufferToPixels(imageBuffer)
        var data = new QuantizerWu, temp;

        data.weights = Array.from({ length: 35937 }).fill(0);
        data.momentsR = Array.from({ length: 35937 }).fill(0);
        data.momentsG = Array.from({ length: 35937 }).fill(0);
        data.momentsB = Array.from({ length: 35937 }).fill(0);
        data.moments = Array.from({ length: 35937 }).fill(0);

        var temp2;
        const countByColor = new Map;

        for (let i = 0; i < pixels.length; i++) {
            const pixel = pixels[i];
            255 > (pixel & 4278190080) >> 24 >>> 0 || countByColor.set(pixel, (null !== (temp2 = countByColor.get(pixel)) && void 0 !== temp2 ? temp2 : 0) + 1)
        }
        for (const [chunk1, chunk2] of countByColor.entries()) {
            const pixel = chunk1
            const count = chunk2
            const red = (pixel & 16711680) >> 16
            const green = (pixel & 65280) >> 8
            const blue = pixel & 255
            const index = getIndex((red >> 3) + 1, (green >> 3) + 1, (blue >> 3) + 1);
            data.weights[index] = (null !== (temp = data.weights[index]) && void 0 !== temp ? temp : 0) + count;
            data.momentsR[index] += count * red;
            data.momentsG[index] += count * green;
            data.momentsB[index] += count * blue;
            data.moments[index] += count * (red * red + green * green + blue * blue)
        }
        for (let r = 1; 33 > r; r++) {
            const area = Array.from({ length: 33 }).fill(0)
            const areaR = Array.from({ length: 33 }).fill(0)
            const areaG = Array.from({ length: 33 }).fill(0)
            const areaB = Array.from({ length: 33 }).fill(0)
            const area2 = Array.from({ length: 33 }).fill(0);

            for (let g = 1; 33 > g; g++) {
                let line = 0
                let lineR = 0
                let lineG = 0
                let lineB = 0
                let line2 = 0;

                for (let b = 1; 33 > b; b++) {
                    const index = getIndex(r, g, b);
                    line += data.weights[index];
                    lineR += data.momentsR[index];
                    lineG += data.momentsG[index];
                    lineB += data.momentsB[index];
                    line2 += data.moments[index];
                    area[b] += line;
                    areaR[b] += lineR;
                    areaG[b] += lineG;
                    areaB[b] += lineB;
                    area2[b] += line2;
                    const previousIndex = getIndex(r - 1, g, b);
                    data.weights[index] = data.weights[previousIndex] + area[b];
                    data.momentsR[index] = data.momentsR[previousIndex] + areaR[b];
                    data.momentsG[index] = data.momentsG[previousIndex] + areaG[b];
                    data.momentsB[index] = data.momentsB[previousIndex] + areaB[b];
                    data.moments[index] = data.moments[previousIndex] + area2[b]
                }
            }
        }
        
        var colorCount = createBoxes(data).resultCount;
        const colors = [];

        for (let i = 0; i < colorCount; ++i) {
            const cube = data.cubes[i]
            const weight = data.volume(cube, data.weights);
            if (0 < weight) {
                const r = Math.round(data.volume(cube, data.momentsR) / weight)
                const g = Math.round(data.volume(cube, data.momentsG) / weight)
                const b = Math.round(data.volume(cube, data.momentsB) / weight);
                colors.push(-16777216 | (r & 255) << 16 | (g & 255) << 8 | b & 255)
            }
        }
        const pixelToCount = new Map
        const points = []
        const pixels$jscomp$0 = []
        const pointProvider = new LabPointProvider;
        let pointCount = 0;

        for (let i = 0; i < pixels.length; i++) {
            const inputPixel = pixels[i]
            const pixelCount = pixelToCount.get(inputPixel);
            void 0 === pixelCount ? (pointCount++,
                points.push(labFromInt(inputPixel)),
                pixels$jscomp$0.push(inputPixel),
                pixelToCount.set(inputPixel, 1)) : pixelToCount.set(inputPixel, pixelCount + 1)
        }

        const counts = [];
        for (let i = 0; i < pointCount; i++) {
            const count = pixelToCount.get(pixels$jscomp$0[i]);
            void 0 !== count && (counts[i] = count)
        }

        let clusterCount = Math.min(256, pointCount);
        0 < colors.length && (clusterCount = Math.min(clusterCount, colors.length));
    
        const clusters = [];
        for (let i = 0; i < colors.length; i++) clusters.push(labFromInt(colors[i]));

        const additionalClustersNeeded = clusterCount - clusters.length;
        if (0 === colors.length && 0 < additionalClustersNeeded)
            for (let i = 0; i < additionalClustersNeeded; i++)
                clusters.push([100 * Math.random(), 201 * Math.random() + -100, 201 * Math.random() + -100]);

        const clusterIndices = [];
        for (let i = 0; i < pointCount; i++)
            clusterIndices.push(Math.floor(Math.random() * clusterCount));
        const indexMatrix = [];
        for (let i = 0; i < clusterCount; i++) {
            indexMatrix.push([]);
            for (let j = 0; j < clusterCount; j++)
                indexMatrix[i].push(0)
        }
        const distanceToIndexMatrix = [];
        for (let i = 0; i < clusterCount; i++) {
            distanceToIndexMatrix.push([]);
            for (let j = 0; j < clusterCount; j++)
                distanceToIndexMatrix[i].push(new quantizer_wsmeans_DistanceAndIndex)
        }
        const pixelCountSums = [];
        for (let i = 0; i < clusterCount; i++)
            pixelCountSums.push(0);
        for (let iteration = 0; 10 > iteration; iteration++) {
            for (let i = 0; i < clusterCount; i++) {
                for (let j = i + 1; j < clusterCount; j++) {
                    const distance = pointProvider.distance(clusters[i], clusters[j]);
                    distanceToIndexMatrix[j][i].distance = distance;
                    distanceToIndexMatrix[j][i].index = i;
                    distanceToIndexMatrix[i][j].distance = distance;
                    distanceToIndexMatrix[i][j].index = j
                }
                distanceToIndexMatrix[i].sort();
                for (let j = 0; j < clusterCount; j++)
                    indexMatrix[i][j] = distanceToIndexMatrix[i][j].index
            }
            let pointsMoved = 0;
            for (let i = 0; i < pointCount; i++) {
                const point = points[i]
                    , previousClusterIndex = clusterIndices[i]
                    , previousDistance = pointProvider.distance(point, clusters[previousClusterIndex]);
                let minimumDistance = previousDistance
                    , newClusterIndex = -1;
                for (let j = 0; j < clusterCount; j++) {
                    if (distanceToIndexMatrix[previousClusterIndex][j].distance >= 4 * previousDistance)
                        continue;
                    const distance = pointProvider.distance(point, clusters[j]);
                    distance < minimumDistance && (minimumDistance = distance,
                        newClusterIndex = j)
                }
                -1 !== newClusterIndex && 3 < Math.abs(Math.sqrt(minimumDistance) - Math.sqrt(previousDistance)) && (pointsMoved++,
                    clusterIndices[i] = newClusterIndex)
            }
            if (0 === pointsMoved && 0 !== iteration)
                break;
            const componentASums = Array(clusterCount).fill(0)
                , componentBSums = Array(clusterCount).fill(0)
                , componentCSums = Array(clusterCount).fill(0);
            for (let i = 0; i < clusterCount; i++)
                pixelCountSums[i] = 0;
            for (let i = 0; i < pointCount; i++) {
                const clusterIndex = clusterIndices[i]
                    , point = points[i]
                    , count = counts[i];
                pixelCountSums[clusterIndex] += count;
                componentASums[clusterIndex] += point[0] * count;
                componentBSums[clusterIndex] += point[1] * count;
                componentCSums[clusterIndex] += point[2] * count
            }
            for (let i = 0; i < clusterCount; i++) {
                const count = pixelCountSums[i];
                clusters[i] = 0 === count ? [0, 0, 0] : [componentASums[i] / count, componentBSums[i] / count, componentCSums[i] / count]
            }
        }
        const argbToPopulation = new Map;
        for (let i = 0; i < clusterCount; i++) {
            const count = pixelCountSums[i];
            if (0 === count)
                continue;
            const possibleNewCluster = pointProvider.toInt(clusters[i]);
            argbToPopulation.has(possibleNewCluster) || argbToPopulation.set(possibleNewCluster, count)
        }
        const ranked = monetscore(argbToPopulation);
        return hexFromInt(ranked[0])
    }

    const monetfilter = function (colorsToExcitedProportion, colorsToCam) {
        const filtered = [];
        for (const [color__tsickle_destructured_8, cam__tsickle_destructured_9] of colorsToCam.entries()) {
            const color = color__tsickle_destructured_8
                , cam = cam__tsickle_destructured_9
                , proportion = colorsToExcitedProportion.get(color);
            15 <= cam.chroma && 10 <= lstarFromInt(color) && .01 <= proportion && filtered.push(color)
        }
        return filtered
    };


    function math_utils_sanitizeDegrees(degrees) {
        return 0 > degrees ? degrees % 360 + 360 : 360 <= degrees ? degrees % 360 : degrees
    }

    var monetscore = function (colorsToPopulation) {
        let populationSum = 0;
        for (const population of colorsToPopulation.values())
            populationSum += population;
        const colorsToProportion = new Map
        const colorsToCam = new Map
        const hueProportions = Array(360).fill(0);
        for (const [color__tsickle_destructured_1, population__tsickle_destructured_2] of colorsToPopulation.entries()) {
            const color = color__tsickle_destructured_1
            const proportion = population__tsickle_destructured_2 / populationSum;
            colorsToProportion.set(color, proportion);
            const cam = libmonetfromIntInViewingConditions(color);
            colorsToCam.set(color, cam);
            hueProportions[Math.round(cam.hue)] += proportion
        }
        const colorsToExcitedProportion = new Map;
        for (const [color__tsickle_destructured_3, cam__tsickle_destructured_4] of colorsToCam.entries()) {
            const color = color__tsickle_destructured_3
            const hue = Math.round(cam__tsickle_destructured_4.hue);
            let excitedProportion = 0;
            for (let i = hue - 15; i < hue + 15; i++)
                excitedProportion += hueProportions[math_utils_sanitizeDegrees(i)];
            colorsToExcitedProportion.set(color, excitedProportion)
        }
        const colorsToScore = new Map;
        for (const [color__tsickle_destructured_5, cam__tsickle_destructured_6] of colorsToCam.entries()) {
            const color = color__tsickle_destructured_5
            const cam = cam__tsickle_destructured_6
            const proportionScore = 70 * colorsToExcitedProportion.get(color);
            colorsToScore.set(color, proportionScore + (cam.chroma - 48) * (48 > cam.chroma ? .1 : .3))
        }
        const filteredColors = monetfilter(colorsToExcitedProportion, colorsToCam)
        const dedupedColorsToScore = new Map;
        for (const color of filteredColors) {
            let duplicateHue = !1;
            const hue = colorsToCam.get(color).hue;
            for (const [alreadyChosenColor__tsickle_destructured_7] of dedupedColorsToScore) {
                const alreadyChosenHue = colorsToCam.get(alreadyChosenColor__tsickle_destructured_7).hue;
                if (15 > 180 - Math.abs(Math.abs(hue - alreadyChosenHue) - 180)) {
                    duplicateHue = !0;
                    break
                }
            }
            duplicateHue || dedupedColorsToScore.set(color, colorsToScore.get(color))
        }
        const colorsByScoreDescending = Array.from(dedupedColorsToScore.entries());
        colorsByScoreDescending.sort((first, second) => second[1] - first[1]);
        const answer = colorsByScoreDescending.map(entry => entry[0]);
        0 === answer.length && answer.push(4282549748);
        return answer
    }

    class quantizer_wu_Box {
        constructor() {
            this.vol = this.b1 = this.b0 = this.g1 = this.g0 = this.r1 = this.r0 = 0
        }
    }

    class quantizer_wu_CreateBoxesResult {
        constructor(resultCount) {
            this.resultCount = resultCount
        }
    }

    const cut = function (self, one, two) {
        const wholeR = self.volume(one, self.momentsR)
        const wholeG = self.volume(one, self.momentsG)
        const wholeB = self.volume(one, self.momentsB)
        const wholeW = self.volume(one, self.weights)
        const maxRResult = maximize(self, one, "red", one.r0 + 1, one.r1, wholeR, wholeG, wholeB, wholeW)
        const maxGResult = maximize(self, one, "green", one.g0 + 1, one.g1, wholeR, wholeG, wholeB, wholeW)
        const maxBResult = maximize(self, one, "blue", one.b0 + 1, one.b1, wholeR, wholeG, wholeB, wholeW);
        let direction;
        const maxR = maxRResult.maximum
        const maxG = maxGResult.maximum
        const maxB = maxBResult.maximum;
        if (maxR >= maxG && maxR >= maxB) {
            if (0 > maxRResult.cutLocation)
                return !1;
            direction = "red"
        } else
            direction = maxG >= maxR && maxG >= maxB ? "green" : "blue";
        two.r1 = one.r1;
        two.g1 = one.g1;
        two.b1 = one.b1;
        switch (direction) {
            case "red":
                one.r1 = maxRResult.cutLocation;
                two.r0 = one.r1;
                two.g0 = one.g0;
                two.b0 = one.b0;
                break;
            case "green":
                one.g1 = maxGResult.cutLocation;
                two.r0 = one.r0;
                two.g0 = one.g1;
                two.b0 = one.b0;
                break;
            case "blue":
                one.b1 = maxBResult.cutLocation;
                two.r0 = one.r0;
                two.g0 = one.g0;
                two.b0 = one.b1;
                break;
            default:
                throw Error("unexpected direction " + direction);
        }
        one.vol = (one.r1 - one.r0) * (one.g1 - one.g0) * (one.b1 - one.b0);
        two.vol = (two.r1 - two.r0) * (two.g1 - two.g0) * (two.b1 - two.b0);
        return !0
    }

    const variance = function (self, cube) {
        const dr = self.volume(cube, self.momentsR)
        const dg = self.volume(cube, self.momentsG)
        const db = self.volume(cube, self.momentsB)
        const xx = self.moments[getIndex(cube.r1, cube.g1, cube.b1)] - self.moments[getIndex(cube.r1, cube.g1, cube.b0)] - self.moments[getIndex(cube.r1, cube.g0, cube.b1)] + self.moments[getIndex(cube.r1, cube.g0, cube.b0)] - self.moments[getIndex(cube.r0, cube.g1, cube.b1)] + self.moments[getIndex(cube.r0, cube.g1, cube.b0)] + self.moments[getIndex(cube.r0, cube.g0, cube.b1)] - self.moments[getIndex(cube.r0, cube.g0, cube.b0)]
        const hypotenuse = dr * dr + dg * dg + db * db
        const volume = self.volume(cube, self.weights);
        return xx - hypotenuse / volume
    }

    class quantizer_wu_MaximizeResult {
        constructor(cutLocation, maximum) {
            this.cutLocation = cutLocation;
            this.maximum = maximum
        }
    }

    const maximize = function (self, cube, direction, first, last, wholeR, wholeG, wholeB, wholeW) {
        const bottomR = self.bottom(cube, direction, self.momentsR)
        const bottomG = self.bottom(cube, direction, self.momentsG)
        const bottomB = self.bottom(cube, direction, self.momentsB)
        const bottomW = self.bottom(cube, direction, self.weights);
        let max = 0, cut = -1, halfR, halfG, halfB, halfW;
        for (let i = first; i < last; i++) {
            halfR = bottomR + self.top(cube, direction, i, self.momentsR);
            halfG = bottomG + self.top(cube, direction, i, self.momentsG);
            halfB = bottomB + self.top(cube, direction, i, self.momentsB);
            halfW = bottomW + self.top(cube, direction, i, self.weights);
            if (0 === halfW)
                continue;
            let tempNumerator = halfR * halfR + halfG * halfG + halfB * halfB
            var tempDenominator = 1 * halfW
            var temp = tempNumerator / tempDenominator;
            halfR = wholeR - halfR;
            halfG = wholeG - halfG;
            halfB = wholeB - halfB;
            halfW = wholeW - halfW;
            0 !== halfW && (tempNumerator = halfR * halfR + halfG * halfG + halfB * halfB,
                tempDenominator = 1 * halfW,
                temp += tempNumerator / tempDenominator,
                temp > max && (max = temp,
                    cut = i))
        }
        return new quantizer_wu_MaximizeResult(cut, max)
    }

</script>

</html>